local data = require("main.game_data")
local game_save = require("main.game.game_save")
local UI_Mods = require("UI.UI_Modules")

function init(self)
	msg.post(".", "acquire_input_focus")
	print(data.getSwitchPower())
	self.running = false
	self.timer = 0
end

local function updateClock(self, dt)
	self.timer = self.timer + dt
	local minute = string.format("%02d", self.timer/60)
	local second = string.format("%02d", self.timer-(minute*60))
	gui.set_text(gui.get_node("text/clock"), minute..":"..second)
	UI_Mods.Clock.setTime(gui.get_node("clock_hand"), second)
	game_save.setTime(self.timer)
end

function update(self, dt)
	if self.running == true then
		updateClock(self, dt)
	end
end

local function pause(self)
	if self.running == true then
		UI_Mods.Submenu.toggle_menu("Pause", vmath.vector3(320,110,0), true)
		UI_Mods.Submenu.toggle_menu("Top", vmath.vector3(320,110,0), true)
		self.running = false
	else
		UI_Mods.Submenu.toggle_menu("Pause", vmath.vector3(320,1136,0), true)
		UI_Mods.Submenu.toggle_menu("Top", vmath.vector3(320,1136,0), true)
		self.running = true
	end
end

local function change_mute(self)
	if self.muted then
		gui.play_flipbook(gui.get_node("mute"), "button_mute")
	else
		gui.play_flipbook(gui.get_node("mute"), "button_unmute")
	end
	msg.post("/music#music_control", "mute",{muted = self.muted})
end

local function special_button(self,name,state)
	if self.special_buttons[name] == true or state == false then
		self.special_buttons[name] = false
		gui.play_flipbook(gui.get_node(name.."_power"), name.."_power_reverse")
	elseif data[name.."_power"] >= 1 then
		self.special_buttons[name] = true
		gui.play_flipbook(gui.get_node(name.."_power"), name.."_power")
	end
	msg.post("/game#Board_control", name.."_power",{value = self.special_buttons[name]})
end

local function saveTime(self)
	game_save.setTime(self.timer);
end

local message_functions = {
	["begin_timer"] = function (self,message,sender)
		self.timer = message.time
		self.running = true
		UI_Mods.Clock.setTime(gui.get_node("clock_hand"), self.timer/60)
	end,
	["stop_timer"] = function (self,message,sender)
		UI_Mods.Clock.setTime(gui.get_node("clock_hand"), 0)
		msg.post(sender, "end_time",{time = self.timer})
		self.running = false
	end,
	["switch_done"] = function (self,message,sender)
		special_button(self, "switch",false)
		gui.set_text(gui.get_node("switch_amount"), "x"..data.getSwitchPower())
	end,
	["loaded_data"] = function (self,message,sender)
	   gui.set_text(gui.get_node("switch_amount"), "x"..data.getSwitchPower())
	   gui.set_text(gui.get_node("text/crystals"),data.getCrystals())
   end,
   ["game_end"] = function (self,message,sender)
	   self.timer = 0
   end,
   ["unpause"] = function (self,message,sender)
	   pause(self)
   end,
}

function on_message(self, message_id, message, sender)
	for i,v in pairs(message_functions) do --probably don't need a loop
		if message_id == hash(i) then
			v(self,message,sender)
		end
	end
end

local function changeToMain()
	msg.post("/ui_fade#fade", "fade")
		timer.delay(0.4, false, function (self, handle, time_elapsed)
			msg.post("/gui#main_UI", "enable")
			msg.post("#", "disable")
		end)
end

local pick_node_actions = {
	--Abilities
	["switch_power"] = function (self) 
		special_button(self,"switch")
	end,
	--PAUSE
	["pause"] = function (self) 
		pause(self)
	end,
	["resume"] = function (self) 
		UI_Mods.Buttons.Press(gui.get_node("resume"), "Resume")
		pause(self)
	end,
	["options"] = function (self) 
		self.current_menu = "Options"
		UI_Mods.Buttons.Press(gui.get_node("options"), "Options")
		UI_Mods.Submenu.toggle_menu("Pause", vmath.vector3(960,110,0), false)
		UI_Mods.Submenu.toggle_menu("Top", vmath.vector3(960,110,0), false)
		UI_Mods.Submenu.toggle_menu("Options", vmath.vector3(640,0,0), true)
		UI_Mods.Buttons.Hover(gui.get_node("Options/back"), "Back",false)
		timer.delay(1,false,function (self, handle, time_elapsed)
			gui.set_enabled(gui.get_node("Options/back"), true)
		end)
	end,
	["Options/back"] = function (self)
		gui.set_enabled(gui.get_node("Options/back"), false)
		UI_Mods.Submenu.toggle_menu("Options", vmath.vector3(0,0,0), false)
		UI_Mods.Submenu.toggle_menu("Pause", vmath.vector3(320,110,0), true)
		UI_Mods.Submenu.toggle_menu("Top", vmath.vector3(320,110,0), true)
		self.current_menu = "Pause"
	end,
	["quit"] = function (self)
		self.current_menu = "Start"
		self.current_state = "Waiting"
		msg.post("/game#Board_control", "clear")
		UI_Mods.Buttons.Press(gui.get_node("quit"), "Quit")
		pause(self) -- if the quit button is shown the game is already paused, this is incase the game is resumed later
		self.running = false -- don't let the timer keep going though (hacky fix could use a better implementation of pause)
		changeToMain()
	end
}

function on_input(self, action_id, action)
	if action_id == hash("tap") and action.pressed then
		for i,v in pairs(pick_node_actions) do
			if gui.pick_node(gui.get_node(i), action.x, action.y) then
				v(self)
			end
		end
	elseif action_id == nil and self.current_menu == "Store" then
		if gui.pick_node(gui.get_node("Store/back"), action.x, action.y) then
			UI_Mods.Buttons.Hover(gui.get_node("Store/back"), "Back",true)
		else
			UI_Mods.Buttons.Hover(gui.get_node("Store/back"), "Back",false)
		end
	elseif action_id == nil and self.current_menu == "Options" then
		if gui.pick_node(gui.get_node("Options/back"), action.x, action.y) then
			UI_Mods.Buttons.Hover(gui.get_node("Options/back"), "Back",true)
		else
			UI_Mods.Buttons.Hover(gui.get_node("Options/back"), "Back",false)
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
